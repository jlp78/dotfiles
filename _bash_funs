# -*- shell-script -*-

case "x$TERM" in
  xxterm*|xscreen)
    # probably can support title bar setting with ansi codes
    settitle () {
      echo -en "\033]0;$1\a"
    }
    ;;
esac
    
# on some terminals, such as bad vt100 clones, this can cause
# crap to pop out all over the screen.  on real vt100 terminals
# and others that have a hardware status line, this updates the
# status bar on the bottom line
if tput tsl >/dev/null; then
  # definitely supports title bar/status line setting
  settitle () {
    tput tsl; echo -n "$1"; tput fsl
  }
fi

# old csh commands
setenv () {
  export $1="$2"
}

unsetenv () {
  unset $*
}

# quiet type - just return the exit code
qtype () {
  type "$@" >/dev/null 2>&1
}

# recursive ls piped through $PAGER
lr () {
  ls -alR $* | $PAGER
}

# annoyingly, some versions of dc don't support everything
# that this command requires.  get used to using jot on those.
range () {
  case "x$2" in
    x)
      start=1
      end=$1
      incr=1
      ;;
    x[0-9]*)
      start=$1
      end=$2
      case "x$3" in
        x)
          incr=1
          ;;
        x[0-9]*)
          incr=$3
          ;;
      esac
  esac
  usage=0
  case "x$start" in
    x*[^0-9]*|x)
      usage=1
      ;;
  esac
  case "x$end" in
    x*[^0-9]*|x)
      usage=1
      ;;
  esac
  case "x$incr" in
    x*[^0-9]*|x)
      usage=1
      ;;
  esac
  if [ $usage -eq 1 ]; then
      echo "args must be numeric"
      echo "usage: range [ a [ b { c } ] ]"
      echo "  if one argument, arg is end, start and incr is 1."
      echo "  if two arguments, args are start and end, incr is 1."
      echo "  if three arguments, args are start, end, and incr."
      return -1
  fi

  if qtype jot; then
    jot - $start $end $incr
  elif qtype dc; then
    echo '[li p' $incr '+ d si' $end '!<a] sa' $start 'silax' | dc
  elif qtype perl; then
    # no dc or jot?  sheesh, let's just fake it with perl
    perl -e '$start = shift; $end = shift; $incr = shift;
             for ($i = $start; $i <= $end; $i += $incr) {
               print $i, "\n";
             }' $start $end $incr
  else
    # no perl, either?  gasp!
    echo "sorry, man, I tried.  you're on your own.  here, let me"
    echo "get you started... 1 2 3 4"
    return -1
  fi
}

# csh used to have this thing called "which" that would tell you
# which thing in your path was going to get run when you typed a
# non-qualified command in.  unfortunately, the csh version ran
# in a subshell and could get it wrong if you had locally modified
# your path in some way.  this shell function uses the shell builtin
# "type" to do the same thing, but it's more accurate since it runs
# right in the same shell you are using.
which () {
  local doall=
  local shellin=
  local usage="usage:  which [ -a ] [ -s ] prog [ prog ... ]
        -a := show all matches
        -s := show path only"

  if [ "$1" = "" ]; then
    echo $usage
    return -1
  fi
  if [ "$1" = "-a" -o "$1" = "-s" ]; then
    if [ "$1" = "-a" ]; then
      doall=-all
    else
      shellin=-path
    fi
    shift
  fi
  if [ "$1" = "-a" -o "$1" = "-s" ]; then
    if [ "$1" = "-a" ]; then
      doall=-all
    else
      shellin=-path
    fi
    shift
  fi
  if [ "$1" = "" ]; then
    echo $usage
    return
  fi

  while [ "$1" != "" ]; do

    if [ "$1" != "`basename $1`" ]; then
      echo "which: do not specify a path"
      return
    fi

    type $doall $shellin $1

    shift
  done
}

# some simple functions to handle remembering choice tidbits
# in a plain text file.  I use this thing all the time.  I
# used to have MEMORY_FILE be $HOME/.memory, but I've since
# moved it into my Drobox, which is very handy as it automatically
# stays up-to-date on multiple machines now.
memorize () {
  if [ -f $MEMORY_FILE ]; then
    echo "-- " >> $MEMORY_FILE
  fi

  case "x$1" in
    x)
      echo "enter text to be memorized"
      cat - >> $MEMORY_FILE
      echo "text has been memorized"
      ;;
    *)
      echo "$@" >> $MEMORY_FILE
      echo "arguments have been memorized"
      ;;
  esac
}

remember () {
  if [ -f $MEMORY_FILE ]; then
    case "x$1" in
      x)
        less -i $MEMORY_FILE
        ;;
      *)
        grep -i "$1" $MEMORY_FILE | less -i
        ;;
    esac
  fi
}

## functions for bluehost/EIG
k () {
  ssh keyserv.unifiedlayer.com "$1"
}

# from quora:
# http://www.quora.com/What-are-some-of-the-best-command-prompt-or-terminal-tricks

extract () {
   if [ -f "$1" ] ; then
       case $1 in
           *.tar.bz2)   tar xvjf "$1"    ;;
           *.tar.gz)    tar xvzf "$1"    ;;
           *.bz2)       bunzip2 "$1"     ;;
           *.rar)       unrar x "$1"     ;;
           *.gz)        gunzip "$1"      ;;
           *.tar)       tar xvf "$1"     ;;
           *.tbz2)      tar xvjf "$1"    ;;
           *.tgz)       tar xvzf "$1"    ;;
           *.zip)       unzip "$1"       ;;
           *.Z)         uncompress "$1"  ;;
           *.7z)        7z x "$1"        ;;
           *)           echo "don't know how to extract '$1'..." ;;
       esac
   else
       echo "'$1' is not a valid file"
   fi
}

# this doesn't appear to work any more... maybe weatherunderground
# is requiring a key of some kind for their api access.  It appears
# to work from my browser, but not from curl.
weather() {
    wu="http://api.wunderground.com/auto/wui/geo/ForcastXML/index.xml"
    curl -s "$wu?query=${@:-84123}" |
    gunzip |
    perl -ne 's/&amp;deg;/Â°/g;
              /<title>([^<]+)/ && printf "%s: ", $1;
              /<fcttext>([^<]+)/ && print $1, "\n"'
}

define() {
  curl -s "http://www.collinsdictionary.com/dictionary/english/$*" |
    sed -n '/class="def"/p' |
    awk '{gsub(/.*<span class="def">|<\/span>.*/,"");print}' |
    sed "s/<[^>]\+>//g" |
    par
}

epoch() {
  TESTREG="[\d{10}]"
  if [[ "$1" =~ $TESTREG ]]; then
    # is epoch
    date -d @$*
  else
    # is date
    if [ $# -gt 0 ]; then
      date +%s --date="$*"
    else
      date +%s
    fi
  fi
}

# named kill, yeah, some platforms have "killall" that does this, but on
# some other platforms (I'm looking at you, Solaris), killall will shut
# the system down for you (if you're root).  probably don't want to do that.
# this script tries to figure out if you've got pkill or a sane killall
# and falls back to grepping the output of ps if all else fails.
nkill () {
  usage="usage: nkill [ -u uid ] [ -s signal ] pattern"

  # defaults
  uid=`id -u`
  sig=TERM

  # process args
  while [ "$1" ]; do
    case "x$1" in
      x-u)
	uid="$2"
	shift; shift
	;;
      x-s)
	sig="$2"
	shift; shift;
	;;
      x)
	echo "no pattern passed"
	echo $usage
	return
	;;
      x*)
	pattern="$1"
	shift
	;;
    esac
  done

  # sanity check args
  case "x$uid" in
    x)
      echo "-u option specified but no uid given"
      echo $usage
      return
      ;;
    x*[^0-9]*)
      echo "uid for -u option must be numeric"
      echo $usage
      return
      ;;
  esac

  case "x$sig" in
    xSIG*)
      :
      ;;
    x[0-9]*)
      :
      ;;
    *)
      sig="SIG$sig"
      ;;
  esac
    
  if kill -l | grep -sqw "$sig"; then
    :
  else
    echo "unknown signal, select from one of these"
    kill -l
    echo $usage
    return
  fi

  if qtype pkill; then
    pkill -"$sig" -U "$uid" "$pattern"
  elif qtype killall; then
    killall -u "$uid" -"$sig" "$pattern"
  else
    ps -efu | awk '/$pattern/ {print $1, $2}' | awk '/^$uid / {print $2}' |
      while read pid; do
	kill -"$sig" $pid
      done
  fi
}

# update the PS1 string... and other magic.
prompt_update () {
  case "$interactive" in
    true)
      :
      ;;
    *)
      # don't be setting the prompt on a non-interactive shell
      return
      ;;
  esac
  
  # update the history... this keeps a common history between
  # all shells on the same machine.  this takes some getting used
  # to unless you're familiar with ksh that does this by default.
  history -a; history -c; history -r #nkill -s USR1 bash

  # virtual env active?
  if [ "$VIRTUAL_ENV" ]; then
    venv="(`basename \"$VIRTUAL_ENV\"`) "
  else
    venv=""
  fi

  # set the title bar/status line if we can
  qtype settitle && settitle "$(id -nu)@$(hostname -s):$(pwd)"

  # default in case __git_ps1 isn't there
  PS1="${venv}\u@\h:\w\n\! bash\\\$ "

  # set up the PS1, ugh, what a mess.  yes, we have embedded a newline
  # in the prompt string.  I used to really hate prompts that do this,
  # but there is just too much noise in the prompt to keep it on the same
  # line as the command entry now.
  qtype __git_ps1 && __git_ps1 "${venv}\u@\h:\w" "\n\! bash\\\$ "
}
